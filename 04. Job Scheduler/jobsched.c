//jobsched.c
//Yifan Yu

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <inttypes.h>
#include "jobs.h"

#define streq(s0, s1) (strcmp((s0), (s1)) == 0)

list* job_queue;

void handler(int sig){
	int status;
	pid_t pid;
	pid = wait(&status);
	if (WIFEXITED(status)){
		job_complete(job_queue, pid, WEXITSTATUS(status));
	}
}
void* schedThreadFunc(void* arg){
	signal(SIGCHLD, handler);
	while(1){

		select_job_to_run(job_queue);
	}
	return NULL;
}

int main(int argc, char* argv[]){
  char line[1000];
  char *words[100];
  char *word;
  int nwords = 0;
  printf("> ");

	job_queue = job_queue_create();
	pthread_t schedThread;
	pthread_create(&schedThread, NULL, schedThreadFunc, NULL);



  while((fgets(line, 1000, stdin)) != NULL){

    word = strtok(line, " \t\n");
    while (word != NULL)
    {
      words[nwords] = word;
      word = strtok(NULL, " \t\n");
      nwords++;
    }
    if(nwords == 0){
      printf("> ");
      fflush(stdout);
      continue;
    }

    char* commands = malloc(sizeof(line));
    strcpy(commands, line);
    commands[strlen(commands) - 1] = 0;
    if (words[0] != NULL){
      commands = commands + strlen(words[0]) + 1;
    }
    //1. Submit
    /* The submit command defines a new job and the Unix command that should be
    run when the job is scheduled. It should return immediately and display a
    unique integer job ID generated internally by your program.
    (Just start at one and count up.)
    The job will then run in the background when selected by the scheduler.*/
    if(strcmp(words[0], "submit") == 0){

      if (words[1] == NULL){
    		fprintf(stderr, "Wrong number of arguments. \nUsage: $ njobs <n>\n");
    		return EXIT_FAILURE;
    	}
    	Job* job = create_job(commands, nwords, words);
    	if (queue_job(job_queue, job) < 0){
    		fprintf(stderr, "Error: Unable to queue a job\n");
    		return EXIT_FAILURE;
    	}
    	printf("Job id: %d is submitted.\n", job->id);

      //2. Status
      /* 2. The status command lists all of the jobs currently known, giving the
      job id, current state (waiting, running, or done) the exit status of the job
      (if done) and the Unix command of the job */
    } else if(strcmp(words[0], "status") == 0){
      char* states[] = {"WAIT", "RUN", "DONE"};
      pthread_mutex_lock(&job_queue->mutex);
      printf("JOBID\tSTATE\tEXIT\tCOMMAND\n");
      for (Job* currJob = job_queue->head; currJob != NULL; currJob = currJob->next){
        if (currJob->state == WAIT || currJob->state == RUN){

          printf("%d\t%s\t%s\t%s\n", currJob->id, states[currJob->state], "-", currJob->commands);
        } else {
          printf("%d\t%s\t%d\t%s\n", currJob->id, states[currJob->state], currJob->exit, currJob->commands);
        }
      }
      pthread_mutex_unlock(&job_queue->mutex);
      //3. Wait
      /* takes a jobid and pauses until that job is done executing. When the job
      is complete, it should display the job ID and command, and then display the
      standard output generated by the job. (If the job was already complete, or
      wait is called multiple times, it should just display the relevant
      information right away.) */
    } else if(strcmp(words[0], "wait") == 0){


      if (words[1] == NULL){
    		fprintf(stderr, "Wrong number of arguments. \nUsage: $ njobs <n>\n");
    		return EXIT_FAILURE;
    	}
    	int id = strtoumax(words[1], NULL, 10);

    	// spin until job is done
    	Job* currJob = job_queue->head;
    	while (currJob != NULL && currJob->id != id){
    		currJob = currJob->next;
    	}
    	if (currJob == NULL){
    		return 1; // not found
    	} else if (currJob->id == id){
    		// spin!
    		while (currJob->state != DONE){}

    		// display contents
    		printf("JOBID\tCOMMAND\n");
    		printf("%d\t%s\n", currJob->id, currJob->commands);
    		// display its output file
    		int c;
    		FILE* file;
    		char inputFileName[20];
    		sprintf(inputFileName, "./outputs/output.%d", id);
    		file = fopen(inputFileName, "r");
    		if (file){
    			while ((c = getc(file)) != EOF)
    				putchar(c);
    			fclose(file);
    		}
    	} else {
    		return EXIT_FAILURE;
    	}
      //4. remove
      /* takes a jobid and then removes it from the queue, also deleting any
      stored output of the job. However, it should only do this if the job is in
      the WAIT or DONE states. If the job is currently running, this command
      should display a suitable error, and refuse to remove the job*/
    } else if(strcmp(words[0], "remove") == 0){

      if (words[1] == NULL){
        fprintf(stderr, "Error: Wrong number of arguments. \nUsage: $ remove <job_id>\n");
        return EXIT_FAILURE;
      }
      int id = strtoumax(words[1], NULL, 10);
      if (remove_job(job_queue, id) < 0){
        fprintf(stderr, "Error: Cannot remove jobs\n");
        return EXIT_FAILURE;
      }
      // return EXIT_SUCCESS;
      //5. njobs
      /*The njobs command indicates how many jobs the scheduler may run at once,
      which should be one by default. */
    } else if(strcmp(words[0], "njobs") == 0){

      if (words[1] == NULL){
        fprintf(stderr, "Error: Wrong number of arguments. \nUsage: $ njobs <n>\n");
        return EXIT_FAILURE;
      }
      int njobs = strtoumax(words[1], NULL, 10);

      set_njobs(job_queue, njobs);

      //6. Drain
      /*wait until all jobs in the queue are in the DONE state. */
    } else if(strcmp(words[0], "drain") == 0){

      pthread_mutex_lock(&job_queue->mutex);

      Job* job = job_queue->head;
      while (job != NULL){
        /* printf("Waiting for job id %d\n", job->id); */
        while (job->state != DONE){
          pthread_cond_wait(&job_queue->cond, &job_queue->mutex);
        }
        /* printf("Finished job id %d\n", job->id); */
        job = job->next;
      }
      pthread_mutex_unlock(&job_queue->mutex);

      //7. Quit
      /*immediately exit the program, regardless of any jobs in the queue.
      (If end-of-file is detected on the input,
      the program should quit in the same way.)*/
    } else if(strcmp(words[0], "quit") == 0){
      return 0;
    } else if(strcmp(words[0], "help") == 0){
      
    }
    nwords = 0;
    printf("> ");
    fflush(stdout);
  }
}
