//jobsched.c
//Yifan Yu

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>

struct job *head = NULL;
int N_JOB = 1;
pthread_mutex_t lock;

struct job
{
  int job_id;
  int state;
  int exit;
  char* command;
  char** argv;
  struct job *next;
};
struct list{
  struct job *head;
};

struct job* job_create(int job_id, char* command, char* argv[]){
  struct job *j = 0;
  j = malloc(sizeof(struct job));
  j->job_id = job_id;
  j->state = 0;
  j->exit = 0;
  j->command = command;
  j->argv = argv;
  return j;
}

void job_dequeue(struct list *l){
  l->head = l->head->next;
}

void* shell_thread_func(){

  printf("main_thread_func");

  char line[1000];
  char *words[100];
  char *word;
  int nwords = 0;
  int job_counter = 1;
  struct job* j;
  printf("> ");

  while((fgets(line, 1000, stdin)) != NULL){

    word = strtok(line, " \t\n");
    while (word != NULL)
    {
      words[nwords] = word;
      word = strtok(NULL, " \t\n");
      nwords++;
    }
    if(nwords == 0){
      printf("> ");
      fflush(stdout);
      continue;
    }
    words[nwords] = NULL;

    //1. Submit
    /* The submit command defines a new job and the Unix command that should be
    run when the job is scheduled. It should return immediately and display a
    unique integer job ID generated internally by your program.
    (Just start at one and count up.)
    The job will then run in the background when selected by the scheduler.*/
    if(strcmp(words[0], "submit") == 0){
      printf("submit entered. \n");
      pthread_mutex_lock(&lock);
      j = job_create(job_counter, words[1], words + 1);
      //linking the jobs
      j->next = head;
      //by assigning the head to the foremost task, it helps the next created task to point to this one
      head = j;
      pthread_mutex_unlock(&lock);

      //2. Status
      /* 2. The status command lists all of the jobs currently known, giving the
      job id, current state (waiting, running, or done) the exit status of the job
      (if done) and the Unix command of the job */
    } else if(strcmp(words[0], "status") == 0){
      printf("status entered. \n");
      if(nwords == 0){
        printf("JOBID   STATE   EXIT COMMAND");

      } else {
        fprintf(stderr, "Error: Too many arguments. Usage: $ submit\n");
      }
      //3. Wait
      /* takes a jobid and pauses until that job is done executing. When the job
      is complete, it should display the job ID and command, and then display the
      standard output generated by the job. (If the job was already complete, or
      wait is called multiple times, it should just display the relevant
      information right away.) */
    } else if(strcmp(words[0], "wait") == 0){
      printf("wait entered. \n");
      int job_id;
      if(nwords == 2){
        job_id = atoi(words[1]);
        printf("waiting for job: %d",job_id);

        pid_t  pid;
        int status = EXIT_SUCCESS;
        pid = wait(&status);
        if(pid < 0){
          if(errno == ECHILD){
            fprintf(stderr, "myshell: No children.\n");
          }
        } else if (status != 0){
          fprintf(stderr, "myshell: process %d exited abnormally with signal %d: %s.\n", pid, WEXITSTATUS(status), strerror(errno));
        } else {
          printf("process %d exited normally with status %d\n", pid, WEXITSTATUS(status));
        }

      } else {
        fprintf(stderr, "Error: Wrong number of arguments. Usage: $ njobs <n>\n");
      }

      //4. remove
      /* takes a jobid and then removes it from the queue, also deleting any
      stored output of the job. However, it should only do this if the job is in
      the WAIT or DONE states. If the job is currently running, this command
      should display a suitable error, and refuse to remove the job*/
    } else if(strcmp(words[0], "remove") == 0){

      if(nwords == 2){

        printf("%d",nwords);
      } else {
        fprintf(stderr, "Error: Wrong number of arguments. Usage: $ njobs <n>\n");
      }

      printf("remove entered. \n");

      //5. njobs
      /*The njobs command indicates how many jobs the scheduler may run at once,
      which should be one by default. */
    } else if(strcmp(words[0], "njobs") == 0){
      printf("njobs entered. \n");
      if(nwords == 2){
        N_JOB = atoi(words[1]);
        printf("%d",nwords);
      } else {
        fprintf(stderr, "Wrong number of arguments. \nUsage: $ njobs <n>\n");
      }

      //6. Drain
      /*wait until all jobs in the queue are in the DONE state. */
    } else if(strcmp(words[0], "drain") == 0){
      printf("drain entered. \n");
      if(nwords == 0){
        while(0)//job queue is not empty
        sleep(1);
      } else {
        fprintf(stderr, "Error: Too many arguments. Usage: $ drain\n");
      }

      //7. Quit
      /*immediately exit the program, regardless of any jobs in the queue.
      (If end-of-file is detected on the input,
      the program should quit in the same way.)*/
    } else if(strcmp(words[0], "quit") == 0){
      printf("quit entered. \n");


    } else if(strcmp(words[0], "help") == 0){
      printf("help entered. \n");
    }
    nwords = 0;
    printf("> ");
    fflush(stdout);

  }
  return 0;

}

void* sched_thread_func(){

  struct list*l = malloc(sizeof(struct list));
  // struct list *a;
  while(1){
    l->head = head;
    // a = (struct list *)l;
    // if(head != NULL){
    //   printf("head %p\n", head);
    //   printf("a head: %p\n", a->head);
    //   printf("l head %p\n", l->head);

    if(l->head != NULL){
      pthread_mutex_lock(&lock);
      struct job *a1 = l->head;
      job_dequeue(l);
      head = l->head;
      pthread_mutex_unlock(&lock);

      pid_t  pid = fork();
      if (pid < 0) {	    // Fork Error
        fprintf(stderr, "myshell: Unable to fork: %s\n", strerror(errno));
      }
      if (pid == 0) {	    // Child

        printf("process %d started\n", getpid());
        if (execvp(a1->command, a1->argv)) {
          fprintf(stderr, "Unable to execvp: %s\n", strerror(errno));
          _exit(EXIT_FAILURE);
        }
      }
      printf("Job %d finished", a1->job_id);
      free(a1);
    }
  }
}

int main( int argc, char *argv[] )
{

  if (pthread_mutex_init(&lock, NULL) != 0)
    {
        printf("\n mutex init has failed\n");
        return 1;
  }
  // pthread_t shell_thread;
  pthread_t sched_thread;
  // int a;
  int b;
  // a = pthread_create(&shell_thread, NULL, shell_thread_func, NULL);
  b = pthread_create(&sched_thread, NULL, sched_thread_func, NULL);

  pthread_join(shell_thread, NULL);

  


  return EXIT_SUCCESS;
}
